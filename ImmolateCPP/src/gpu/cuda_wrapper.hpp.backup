#pragma once

// Dynamic CUDA loader for Windows cross-compilation
// This allows us to build on Linux and run on Windows with CUDA

#ifdef _WIN32
#include <windows.h>
#else
#include <dlfcn.h>
#endif

#include <cstdint>
#include <iostream>

// CUDA types we need
typedef enum {
    cudaSuccess = 0,
    cudaErrorInvalidValue = 1,
    cudaErrorMemoryAllocation = 2,
    cudaErrorInitializationError = 3,
    cudaErrorCudartUnloading = 4,
    cudaErrorProfilerDisabled = 5,
    cudaErrorProfilerNotInitialized = 6,
    cudaErrorProfilerAlreadyStarted = 7,
    cudaErrorProfilerAlreadyStopped = 8,
    cudaErrorInvalidConfiguration = 9,
    cudaErrorInvalidPitchValue = 12,
    cudaErrorInvalidSymbol = 13,
    cudaErrorInvalidHostPointer = 16,
    cudaErrorInvalidDevicePointer = 17,
    cudaErrorInvalidTexture = 18,
    cudaErrorInvalidTextureBinding = 19,
    cudaErrorInvalidChannelDescriptor = 20,
    cudaErrorInvalidMemcpyDirection = 21,
    cudaErrorAddressOfConstant = 22,
    cudaErrorTextureFetchFailed = 23,
    cudaErrorTextureNotBound = 24,
    cudaErrorSynchronizationError = 25,
    cudaErrorInvalidFilterSetting = 26,
    cudaErrorInvalidNormSetting = 27,
    cudaErrorMixedDeviceExecution = 28,
    cudaErrorNotYetImplemented = 31,
    cudaErrorMemoryValueTooLarge = 32,
    cudaErrorStubLibrary = 34,
    cudaErrorInsufficientDriver = 35,
    cudaErrorCallRequiresNewerDriver = 36,
    cudaErrorInvalidSurface = 37,
    cudaErrorDuplicateVariableName = 43,
    cudaErrorDuplicateTextureName = 44,
    cudaErrorDuplicateSurfaceName = 45,
    cudaErrorDevicesUnavailable = 46,
    cudaErrorIncompatibleDriverContext = 49,
    cudaErrorMissingConfiguration = 52,
    cudaErrorPriorLaunchFailure = 53,
    cudaErrorLaunchMaxDepthExceeded = 65,
    cudaErrorLaunchFileScopedTex = 66,
    cudaErrorLaunchFileScopedSurf = 67,
    cudaErrorSyncDepthExceeded = 68,
    cudaErrorLaunchPendingCountExceeded = 69,
    cudaErrorInvalidDeviceFunction = 98,
    cudaErrorNoDevice = 100,
    cudaErrorInvalidDevice = 101,
    cudaErrorDeviceNotLicensed = 102,
    cudaErrorSoftwareValidityNotEstablished = 103,
    cudaErrorStartupFailure = 127,
    cudaErrorInvalidKernelImage = 200,
    cudaErrorDeviceUninitialized = 201,
    cudaErrorMapBufferObjectFailed = 205,
    cudaErrorUnmapBufferObjectFailed = 206,
    cudaErrorArrayIsMapped = 207,
    cudaErrorAlreadyMapped = 208,
    cudaErrorNoKernelImageForDevice = 209,
    cudaErrorAlreadyAcquired = 210,
    cudaErrorNotMapped = 211,
    cudaErrorNotMappedAsArray = 212,
    cudaErrorNotMappedAsPointer = 213,
    cudaErrorECCUncorrectable = 214,
    cudaErrorUnsupportedLimit = 215,
    cudaErrorDeviceAlreadyInUse = 216,
    cudaErrorPeerAccessUnsupported = 217,
    cudaErrorInvalidPtx = 218,
    cudaErrorInvalidGraphicsContext = 219,
    cudaErrorNvlinkUncorrectable = 220,
    cudaErrorJitCompilerNotFound = 221,
    cudaErrorUnsupportedPtxVersion = 222,
    cudaErrorJitCompilationDisabled = 223,
    cudaErrorUnsupportedExecAffinity = 224,
    cudaErrorInvalidSource = 300,
    cudaErrorFileNotFound = 301,
    cudaErrorSharedObjectSymbolNotFound = 302,
    cudaErrorSharedObjectInitFailed = 303,
    cudaErrorOperatingSystem = 304,
    cudaErrorInvalidResourceHandle = 400,
    cudaErrorIllegalState = 401,
    cudaErrorSymbolNotFound = 500,
    cudaErrorNotReady = 600,
    cudaErrorIllegalAddress = 700,
    cudaErrorLaunchOutOfResources = 701,
    cudaErrorLaunchTimeout = 702,
    cudaErrorLaunchIncompatibleTexturing = 703,
    cudaErrorPeerAccessAlreadyEnabled = 704,
    cudaErrorPeerAccessNotEnabled = 705,
    cudaErrorSetOnActiveProcess = 708,
    cudaErrorContextIsDestroyed = 709,
    cudaErrorAssert = 710,
    cudaErrorTooManyPeers = 711,
    cudaErrorHostMemoryAlreadyRegistered = 712,
    cudaErrorHostMemoryNotRegistered = 713,
    cudaErrorHardwareStackError = 714,
    cudaErrorIllegalInstruction = 715,
    cudaErrorMisalignedAddress = 716,
    cudaErrorInvalidAddressSpace = 717,
    cudaErrorInvalidPc = 718,
    cudaErrorIllegalInstruction2 = 719,
    cudaErrorLaunchFailure = 719,
    cudaErrorCooperativeLaunchTooLarge = 720,
    cudaErrorNotPermitted = 800,
    cudaErrorNotSupported = 801,
    cudaErrorSystemNotReady = 802,
    cudaErrorSystemDriverMismatch = 803,
    cudaErrorCompatNotSupportedOnDevice = 804,
    cudaErrorMpsConnectionFailed = 805,
    cudaErrorMpsRpcFailure = 806,
    cudaErrorMpsServerNotReady = 807,
    cudaErrorMpsMaxClientsReached = 808,
    cudaErrorMpsMaxConnectionsReached = 809,
    cudaErrorStreamCaptureUnsupported = 900,
    cudaErrorStreamCaptureInvalidated = 901,
    cudaErrorStreamCaptureMerge = 902,
    cudaErrorStreamCaptureUnmatched = 903,
    cudaErrorStreamCaptureUnjoined = 904,
    cudaErrorStreamCaptureIsolation = 905,
    cudaErrorStreamCaptureImplicit = 906,
    cudaErrorCapturedEvent = 907,
    cudaErrorStreamCaptureWrongThread = 908,
    cudaErrorTimeout = 909,
    cudaErrorGraphExecUpdateFailure = 910,
    cudaErrorExternalDevice = 911,
    cudaErrorUnknown = 999,
    cudaErrorApiFailureBase = 10000
} cudaError_t;

typedef enum {
    cudaMemcpyHostToHost = 0,
    cudaMemcpyHostToDevice = 1,
    cudaMemcpyDeviceToHost = 2,
    cudaMemcpyDeviceToDevice = 3,
    cudaMemcpyDefault = 4
} cudaMemcpyKind;

struct cudaDeviceProp {
    char name[256];
    size_t totalGlobalMem;
    size_t sharedMemPerBlock;
    int regsPerBlock;
    int warpSize;
    size_t memPitch;
    int maxThreadsPerBlock;
    int maxThreadsDim[3];
    int maxGridSize[3];
    int clockRate;
    size_t totalConstMem;
    int major;
    int minor;
    size_t textureAlignment;
    size_t texturePitchAlignment;
    int deviceOverlap;
    int multiProcessorCount;
    int kernelExecTimeoutEnabled;
    int integrated;
    int canMapHostMemory;
    int computeMode;
    int maxTexture1D;
    int maxTexture1DMipmap;
    int maxTexture1DLinear;
    int maxTexture2D[2];
    int maxTexture2DMipmap[2];
    int maxTexture2DLinear[3];
    int maxTexture2DGather[2];
    int maxTexture3D[3];
    int maxTexture3DAlt[3];
    int maxTextureCubemap;
    int maxTexture1DLayered[2];
    int maxTexture2DLayered[3];
    int maxTextureCubemapLayered[2];
    int maxSurface1D;
    int maxSurface2D[2];
    int maxSurface3D[3];
    int maxSurface1DLayered[2];
    int maxSurface2DLayered[3];
    int maxSurfaceCubemap;
    int maxSurfaceCubemapLayered[2];
    size_t surfaceAlignment;
    int concurrentKernels;
    int ECCEnabled;
    int pciBusID;
    int pciDeviceID;
    int pciDomainID;
    int tccDriver;
    int asyncEngineCount;
    int unifiedAddressing;
    int memoryClockRate;
    int memoryBusWidth;
    int l2CacheSize;
    int persistingL2CacheMaxSize;
    int maxThreadsPerMultiProcessor;
    int streamPrioritiesSupported;
    int globalL1CacheSupported;
    int localL1CacheSupported;
    size_t sharedMemPerMultiprocessor;
    int regsPerMultiprocessor;
    int managedMemory;
    int isMultiGpuBoard;
    int multiGpuBoardGroupID;
    int singleToDoublePrecisionPerfRatio;
    int pageableMemoryAccess;
    int concurrentManagedAccess;
    int computePreemptionSupported;
    int canUseHostPointerForRegisteredMem;
    int cooperativeLaunch;
    int cooperativeMultiDeviceLaunch;
    int pageableMemoryAccessUsesHostPageTables;
    int directManagedMemAccessFromHost;
    int accessPolicyMaxWindowSize;
};

// Function pointers for CUDA runtime API
typedef cudaError_t (*cudaMalloc_t)(void**, size_t);
typedef cudaError_t (*cudaFree_t)(void*);
typedef cudaError_t (*cudaMemcpy_t)(void*, const void*, size_t, cudaMemcpyKind);
typedef cudaError_t (*cudaGetDeviceCount_t)(int*);
typedef cudaError_t (*cudaGetDeviceProperties_t)(cudaDeviceProp*, int);
typedef cudaError_t (*cudaSetDevice_t)(int);
typedef cudaError_t (*cudaDeviceSynchronize_t)(void);
typedef cudaError_t (*cudaGetLastError_t)(void);
typedef const char* (*cudaGetErrorString_t)(cudaError_t);

// Dynamic CUDA loader class
class CudaWrapper {
private:
    void* cuda_handle = nullptr;
    bool initialized = false;
    
public:
    // Function pointers
    cudaMalloc_t cudaMalloc = nullptr;
    cudaFree_t cudaFree = nullptr;
    cudaMemcpy_t cudaMemcpy = nullptr;
    cudaGetDeviceCount_t cudaGetDeviceCount = nullptr;
    cudaGetDeviceProperties_t cudaGetDeviceProperties = nullptr;
    cudaSetDevice_t cudaSetDevice = nullptr;
    cudaDeviceSynchronize_t cudaDeviceSynchronize = nullptr;
    cudaGetLastError_t cudaGetLastError = nullptr;
    cudaGetErrorString_t cudaGetErrorString = nullptr;
    
    bool init() {
        if (initialized) return true;
        
#ifdef _WIN32
        // Try to load CUDA runtime DLL on Windows - try all versions
        // First try generic version
        cuda_handle = LoadLibraryA("cudart64.dll");
        
        // Try specific versions from newest to oldest
        if (!cuda_handle) {
            cuda_handle = LoadLibraryA("cudart64_129.dll");  // CUDA 12.9
        }
        if (!cuda_handle) {
            cuda_handle = LoadLibraryA("cudart64_126.dll");  // CUDA 12.6
        }
        if (!cuda_handle) {
            cuda_handle = LoadLibraryA("cudart64_12.dll");   // CUDA 12.x
        }
        if (!cuda_handle) {
            cuda_handle = LoadLibraryA("cudart64_11.dll");   // CUDA 11.x
        }
        if (!cuda_handle) {
            cuda_handle = LoadLibraryA("cudart64_110.dll");  // CUDA 11.0
        }
        if (!cuda_handle) {
            cuda_handle = LoadLibraryA("cudart64_10.dll");   // CUDA 10.x
        }
        if (!cuda_handle) {
            std::cerr << "[GPU] Failed to load CUDA runtime DLL (tried cudart64.dll and versions 10-12.9)" << std::endl;
            return false;
        }
        
        // Load function pointers
        cudaMalloc = (cudaMalloc_t)GetProcAddress((HMODULE)cuda_handle, "cudaMalloc");
        cudaFree = (cudaFree_t)GetProcAddress((HMODULE)cuda_handle, "cudaFree");
        cudaMemcpy = (cudaMemcpy_t)GetProcAddress((HMODULE)cuda_handle, "cudaMemcpy");
        cudaGetDeviceCount = (cudaGetDeviceCount_t)GetProcAddress((HMODULE)cuda_handle, "cudaGetDeviceCount");
        cudaGetDeviceProperties = (cudaGetDeviceProperties_t)GetProcAddress((HMODULE)cuda_handle, "cudaGetDeviceProperties_v2");
        cudaSetDevice = (cudaSetDevice_t)GetProcAddress((HMODULE)cuda_handle, "cudaSetDevice");
        cudaDeviceSynchronize = (cudaDeviceSynchronize_t)GetProcAddress((HMODULE)cuda_handle, "cudaDeviceSynchronize");
        cudaGetLastError = (cudaGetLastError_t)GetProcAddress((HMODULE)cuda_handle, "cudaGetLastError");
        cudaGetErrorString = (cudaGetErrorString_t)GetProcAddress((HMODULE)cuda_handle, "cudaGetErrorString");
#else
        // For Linux testing
        cuda_handle = dlopen("libcudart.so", RTLD_LAZY);
        if (!cuda_handle) {
            return false;
        }
        
        cudaMalloc = (cudaMalloc_t)dlsym(cuda_handle, "cudaMalloc");
        cudaFree = (cudaFree_t)dlsym(cuda_handle, "cudaFree");
        cudaMemcpy = (cudaMemcpy_t)dlsym(cuda_handle, "cudaMemcpy");
        cudaGetDeviceCount = (cudaGetDeviceCount_t)dlsym(cuda_handle, "cudaGetDeviceCount");
        cudaGetDeviceProperties = (cudaGetDeviceProperties_t)dlsym(cuda_handle, "cudaGetDeviceProperties_v2");
        cudaSetDevice = (cudaSetDevice_t)dlsym(cuda_handle, "cudaSetDevice");
        cudaDeviceSynchronize = (cudaDeviceSynchronize_t)dlsym(cuda_handle, "cudaDeviceSynchronize");
        cudaGetLastError = (cudaGetLastError_t)dlsym(cuda_handle, "cudaGetLastError");
        cudaGetErrorString = (cudaGetErrorString_t)dlsym(cuda_handle, "cudaGetErrorString");
#endif
        
        // Check if all functions loaded successfully
        if (!cudaMalloc || !cudaFree || !cudaMemcpy || !cudaGetDeviceCount || 
            !cudaGetDeviceProperties || !cudaSetDevice || !cudaDeviceSynchronize ||
            !cudaGetLastError || !cudaGetErrorString) {
            std::cerr << "Failed to load CUDA functions" << std::endl;
            return false;
        }
        
        initialized = true;
        return true;
    }
    
    void cleanup() {
        if (cuda_handle) {
#ifdef _WIN32
            FreeLibrary((HMODULE)cuda_handle);
#else
            dlclose(cuda_handle);
#endif
            cuda_handle = nullptr;
        }
        initialized = false;
    }
    
    bool is_available() {
        return initialized;
    }
};

// Global CUDA wrapper instance
extern CudaWrapper g_cuda;